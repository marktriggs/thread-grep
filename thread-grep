#!/usr/bin/env ruby

require 'socket'

class Maybe

  ## Constructors
  def self.value(val); Some.new(val); end
  def self.nothing; Nothing.new; end


  class Some
    attr_reader :value

    def initialize(value)
      @value = value
    end

    def has_value?
      true
    end
  end


  class Nothing
    def has_value?
      false
    end

    def value
      raise TypeError.new("#{self} has no value")
    end
  end

end


START_THREAD_DUMP_PATTERN = /Full thread dump Java HotSpot/
FINISH_THREAD_DUMP_PATTERN = /JNI global references|^Heap$/

# Find the most recent JVM thread dump in a (potentially large) log file.
class ThreadDumpExtractor

  CHUNK_SIZE = 32 * 1024


  def initialize(file)
    @file = file
  end


  def call
    file_size = File.size(@file)
    File.open(@file, "r") do |fh|
      (0..file_size).step(CHUNK_SIZE).to_a.reverse.each do |offset|
        upper = [offset + CHUNK_SIZE, file_size].min
        last_thread_dump_position = find_last_thread_dump(fh, offset, upper)

        if last_thread_dump_position.has_value?
          return read_thread_dump(fh, last_thread_dump_position.value)
        end
      end
    end

    raise "No thread dump could be read"
  end


  private

  # Find the start position of the last thread dump between two positions
  def find_last_thread_dump(fh, start_position, end_position)
    fh.seek(start_position, IO::SEEK_SET)
    last_thread_dump_seen = Maybe.nothing

    while fh.tell < end_position
      line_start_position = fh.tell
      line = fh.gets

      if line =~ START_THREAD_DUMP_PATTERN
        last_thread_dump_seen = Maybe.value(line_start_position)
      end
    end

    last_thread_dump_seen
  end


  # Read the thread dump at 'position', returning an array of lines.
  def read_thread_dump(fh, position)
    fh.seek(position, IO::SEEK_SET)

    # Skip the "start thread dump" marker
    fh.gets

    result = []
    while true
      line = fh.gets

      if line.nil? || line =~ FINISH_THREAD_DUMP_PATTERN
        break
      end

      result << line.strip
    end

    result
  end

end

# Grabs a thread dump from a running JVM via the attach protocol
class ThreadDumpAttacher

  def initialize(pid)
    @pid = pid
    @attach_file = "/tmp/.attach_pid#{pid}"
    @socket_file = "/tmp/.java_pid#{pid}"
  end

  def call
    # the JVM won't respond unless our euid and egid match its own
    stat = File.stat "/proc/#{@pid}"
    Process::Sys.setegid stat.gid
    Process::Sys.seteuid stat.uid

    attach unless File.exists?(@socket_file)

    rpc("1\0threaddump\0\0\0\0") do |socket|
      status = socket.readline.strip
      raise "JVM error: #{status}: " + socket.read() unless status == "0"
      timestamp = socket.readline
      raise "Unexpected thread dump format" unless socket.readline =~ START_THREAD_DUMP_PATTERN
      thread_dump = socket.lines.take_while {|line| !(line =~ FINISH_THREAD_DUMP_PATTERN)}
      thread_dump.map {|line| line.strip}
    end
  end

  private

  def attach
    File.open(@attach_file, "w") {}
    begin
      Process.kill("QUIT", @pid)
      20.times do
        return if File.exists?(@socket_file)
        sleep 0.1
      end
      raise "JVM did not respond"
    ensure
      File.delete(@attach_file)
    end
  end

  if RUBY_PLATFORM =~ /.*solaris.*/
    $VERBOSE = nil # suppress DL deprecation warning in Ruby 2.0+
    require 'dl'
    require 'dl/import'
    require 'dl/struct'

    module LibDoor
      begin
        extend DL::Importer # Ruby 1.9+
      rescue NameError
        extend DL::Importable # Ruby 1.8
      end
      dlload "libdoor.so"
      Desc = struct [
        "int attr",
        "int fd",
        "long id_lo",
        "long id_hi",
      ]
      Arg = struct [
        "char *data_ptr",
        "long data_size",
        "Desc *desc_ptr",
        "int desc_num",
        "char *rbuf",
        "long rsize",
      ]
      extern "int door_call(int, Arg*)"
    end

    def rpc(cmd, &block)
      File.open(@socket_file, "r") do |door|
        arg = LibDoor::Arg.malloc
        if cmd.respond_to? :to_ptr
          arg.data_ptr = cmd.to_ptr # Ruby 1.8
        else
          arg.data_ptr = cmd # Ruby 1.9+
        end
        arg.data_size = cmd.size
        arg.desc_ptr = nil
        arg.desc_num = 0
        arg.rbuf = DL::malloc(128)
        arg.rsize = 128

        err = LibDoor.door_call(door.fileno, arg)
        raise "door error #{err}" unless err == 0
        perr = arg.rbuf.to_s(1)[0].ord
        raise "protocol error #{perr}" unless perr == 0

        desc = LibDoor::Desc.new(arg.desc_ptr)
        IO.open(desc.fd, "r") {|io| block.call(io)}
      end
    end
  else
    def rpc(cmd, &block)
      UNIXSocket.open(@socket_file) do |socket|
        socket.send(cmd, 0)
        block.call(socket)
      end
    end
  end
end


# Parse a JVM thread dump log into individual threads.
class ThreadDumpParser
  include Enumerable

  def initialize(s)
    @source_lines = s
  end


  def each
    while (thread = next_thread).has_value?
      yield(thread.value)
    end
  end


  private

  JVMThread = Struct.new(:name, :state, :stack) do

    def name
      translate_nid(self[:name])
    end


    def matches(regexp)
      pattern = /#{regexp}/
      self.name =~ pattern || self.state =~ pattern || self.stack.any? {|frame| frame =~ pattern}
    end

    private

    # Parse out the 'nid' (the OS Thread ID) and show it in base-10 for easier matching up with top(1)
    def translate_nid(s)
      nid_pattern = / nid=0x([a-f0-9]+)/

      if s =~ nid_pattern
        thread_id = $1.hex
        s.gsub(nid_pattern) {|nid| "#{nid} os_thread_id=#{thread_id}"}
      else
        s
      end
    end

  end


  def next_thread
    skip_blanks!

    return Maybe.nothing if @source_lines.empty?

    result = JVMThread.new(@source_lines.shift, "UNKNOWN", [])

    if @source_lines[0] =~ /java\.lang\.Thread\.State: ([A-Z_]+)\b/
      result.state = $1
      @source_lines.shift
    end

    while !eof? && !@source_lines[0].strip.empty?
      result.stack << @source_lines.shift
    end

    Maybe.value(result)
  end


  def eof?
    @source_lines.empty?
  end


  def skip_blanks!
    while !eof? && @source_lines[0].strip.empty?
      @source_lines.shift
    end
  end

end


# Extract and summarise threads matching a given criteria.
class ThreadGrep

  RESET_COLOR = "\033[0m"
  STATE_COLORS = {
    "RUNNABLE" => "\033[1;32m",
    "UNKNOWN" => "\033[1;37m",
    "BLOCKED" => "\033[1;33m",
    "WAITING" => "\033[1;33m",
    "TIMED_WAITING" => "\033[1;33m",
  }
  FRAME_COLORS = {
    /at (javax?|sun|org\.mortbay|org\.restlet|org\.eclipse\.jetty)\./ => "\033[0;37m",
    /- / => "\033[0;36m",
  }

  def frame_color(frame)
    FRAME_COLORS.each do |regex, color|
      return color if frame =~ regex
    end
    ""
  end

  def main
    opts = Trollop::options do
      opt :match, "Show only threads matching pattern", :type => :string, :multi => true
      opt :exclude, "Exclude threads matching pattern", :type => :string, :multi => true
      opt :grep, "Only show stack lines matching pattern", :type => :string, :multi => true
      opt :lines, "Show <lines> lines per thread", :type => :int
      opt :cluster, "Groups threads with identical stack traces"
      opt :color, "Colorize the output {never,auto,always}", :type => :string, :default => 'auto'
      opt :pid, "Attach to a running JVM and obtain a thread dump", :type => :int
    end

    log_file = ARGV.fetch(0, nil)

    unless log_file || opts[:pid]
      $stderr.puts "Usage: #{$0} <log file>"
      $stderr.puts "  Type '-h' for options"
      exit
    end

    use_color = opts[:color] == 'always' || (opts[:color] == 'auto' && STDOUT.tty?)

    if opts[:pid]
      thread_dump = ThreadDumpAttacher.new(opts[:pid]).call
    else
      thread_dump = ThreadDumpExtractor.new(log_file).call
    end

    threads = ThreadDumpParser.new(thread_dump).select do |thread|
      opts[:match].all? {|pattern| thread.matches(pattern)} &&
      opts[:exclude].none? {|pattern| thread.matches(pattern)}
    end

    if opts[:lines]
      threads.each {|thread| thread.stack = thread.stack.take(opts[:lines])}
    end

    if opts[:cluster]
      groups = threads.group_by {|thread| thread.stack}
    else
      groups = threads.map {|thread| [thread.stack, [thread]]}
    end

    groups.each do |stack, threads|
      threads.each do |thread|
        print STATE_COLORS[thread.state] || "" if use_color
        print "#{thread.name} (STATE: #{thread.state})"
        print RESET_COLOR if use_color
        puts ""
      end
      stack.each do |frame|
        next unless opts[:grep].all? {|pattern| frame =~ /#{pattern}/}
        print frame_color(frame) if use_color
        print "  #{frame}"
        print RESET_COLOR if use_color
        puts ""
      end
      puts ""
    end

  end

end


# =======================================================================
# trollop.rb
#
# Copyright (c) 2008--2009 William Morgan. Trollop is distributed under the same
# terms as Ruby.
# =======================================================================

require 'date'

module Trollop

VERSION = "2.0"

## Thrown by Parser in the event of a commandline error. Not needed if
## you're using the Trollop::options entry.
class CommandlineError < StandardError; end

## Thrown by Parser if the user passes in '-h' or '--help'. Handled
## automatically by Trollop#options.
class HelpNeeded < StandardError; end

## Thrown by Parser if the user passes in '-h' or '--version'. Handled
## automatically by Trollop#options.
class VersionNeeded < StandardError; end

## Regex for floating point numbers
FLOAT_RE = /^-?((\d+(\.\d+)?)|(\.\d+))([eE][-+]?[\d]+)?$/

## Regex for parameters
PARAM_RE = /^-(-|\.$|[^\d\.])/

## The commandline parser. In typical usage, the methods in this class
## will be handled internally by Trollop::options. In this case, only the
## #opt, #banner and #version, #depends, and #conflicts methods will
## typically be called.
##
## If you want to instantiate this class yourself (for more complicated
## argument-parsing logic), call #parse to actually produce the output hash,
## and consider calling it from within
## Trollop::with_standard_exception_handling.
class Parser

  ## The set of values that indicate a flag option when passed as the
  ## +:type+ parameter of #opt.
  FLAG_TYPES = [:flag, :bool, :boolean]

  ## The set of values that indicate a single-parameter (normal) option when
  ## passed as the +:type+ parameter of #opt.
  ##
  ## A value of +io+ corresponds to a readable IO resource, including
  ## a filename, URI, or the strings 'stdin' or '-'.
  SINGLE_ARG_TYPES = [:int, :integer, :string, :double, :float, :io, :date]

  ## The set of values that indicate a multiple-parameter option (i.e., that
  ## takes multiple space-separated values on the commandline) when passed as
  ## the +:type+ parameter of #opt.
  MULTI_ARG_TYPES = [:ints, :integers, :strings, :doubles, :floats, :ios, :dates]

  ## The complete set of legal values for the +:type+ parameter of #opt.
  TYPES = FLAG_TYPES + SINGLE_ARG_TYPES + MULTI_ARG_TYPES

  INVALID_SHORT_ARG_REGEX = /[\d-]/ #:nodoc:

  ## The values from the commandline that were not interpreted by #parse.
  attr_reader :leftovers

  ## The complete configuration hashes for each option. (Mainly useful
  ## for testing.)
  attr_reader :specs

  ## Initializes the parser, and instance-evaluates any block given.
  def initialize *a, &b
    @version = nil
    @leftovers = []
    @specs = {}
    @long = {}
    @short = {}
    @order = []
    @constraints = []
    @stop_words = []
    @stop_on_unknown = false

    #instance_eval(&b) if b # can't take arguments
    cloaker(&b).bind(self).call(*a) if b
  end

  ## Define an option. +name+ is the option name, a unique identifier
  ## for the option that you will use internally, which should be a
  ## symbol or a string. +desc+ is a string description which will be
  ## displayed in help messages.
  ##
  ## Takes the following optional arguments:
  ##
  ## [+:long+] Specify the long form of the argument, i.e. the form with two dashes. If unspecified, will be automatically derived based on the argument name by turning the +name+ option into a string, and replacing any _'s by -'s.
  ## [+:short+] Specify the short form of the argument, i.e. the form with one dash. If unspecified, will be automatically derived from +name+.
  ## [+:type+] Require that the argument take a parameter or parameters of type +type+. For a single parameter, the value can be a member of +SINGLE_ARG_TYPES+, or a corresponding Ruby class (e.g. +Integer+ for +:int+). For multiple-argument parameters, the value can be any member of +MULTI_ARG_TYPES+ constant. If unset, the default argument type is +:flag+, meaning that the argument does not take a parameter. The specification of +:type+ is not necessary if a +:default+ is given.
  ## [+:default+] Set the default value for an argument. Without a default value, the hash returned by #parse (and thus Trollop::options) will have a +nil+ value for this key unless the argument is given on the commandline. The argument type is derived automatically from the class of the default value given, so specifying a +:type+ is not necessary if a +:default+ is given. (But see below for an important caveat when +:multi+: is specified too.) If the argument is a flag, and the default is set to +true+, then if it is specified on the the commandline the value will be +false+.
  ## [+:required+] If set to +true+, the argument must be provided on the commandline.
  ## [+:multi+] If set to +true+, allows multiple occurrences of the option on the commandline. Otherwise, only a single instance of the option is allowed. (Note that this is different from taking multiple parameters. See below.)
  ##
  ## Note that there are two types of argument multiplicity: an argument
  ## can take multiple values, e.g. "--arg 1 2 3". An argument can also
  ## be allowed to occur multiple times, e.g. "--arg 1 --arg 2".
  ##
  ## Arguments that take multiple values should have a +:type+ parameter
  ## drawn from +MULTI_ARG_TYPES+ (e.g. +:strings+), or a +:default:+
  ## value of an array of the correct type (e.g. [String]). The
  ## value of this argument will be an array of the parameters on the
  ## commandline.
  ##
  ## Arguments that can occur multiple times should be marked with
  ## +:multi+ => +true+. The value of this argument will also be an array.
  ## In contrast with regular non-multi options, if not specified on
  ## the commandline, the default value will be [], not nil.
  ##
  ## These two attributes can be combined (e.g. +:type+ => +:strings+,
  ## +:multi+ => +true+), in which case the value of the argument will be
  ## an array of arrays.
  ##
  ## There's one ambiguous case to be aware of: when +:multi+: is true and a
  ## +:default+ is set to an array (of something), it's ambiguous whether this
  ## is a multi-value argument as well as a multi-occurrence argument.
  ## In thise case, Trollop assumes that it's not a multi-value argument.
  ## If you want a multi-value, multi-occurrence argument with a default
  ## value, you must specify +:type+ as well.

  def opt name, desc="", opts={}
    raise ArgumentError, "you already have an argument named '#{name}'" if @specs.member? name

    ## fill in :type
    opts[:type] = # normalize
      case opts[:type]
      when :boolean, :bool; :flag
      when :integer; :int
      when :integers; :ints
      when :double; :float
      when :doubles; :floats
      when Class
        case opts[:type].name
        when 'TrueClass', 'FalseClass'; :flag
        when 'String'; :string
        when 'Integer'; :int
        when 'Float'; :float
        when 'IO'; :io
        when 'Date'; :date
        else
          raise ArgumentError, "unsupported argument type '#{opts[:type].class.name}'"
        end
      when nil; nil
      else
        raise ArgumentError, "unsupported argument type '#{opts[:type]}'" unless TYPES.include?(opts[:type])
        opts[:type]
      end

    ## for options with :multi => true, an array default doesn't imply
    ## a multi-valued argument. for that you have to specify a :type
    ## as well. (this is how we disambiguate an ambiguous situation;
    ## see the docs for Parser#opt for details.)
    disambiguated_default = if opts[:multi] && opts[:default].is_a?(Array) && !opts[:type]
      opts[:default].first
    else
      opts[:default]
    end

    type_from_default =
      case disambiguated_default
      when Integer; :int
      when Numeric; :float
      when TrueClass, FalseClass; :flag
      when String; :string
      when IO; :io
      when Date; :date
      when Array
        if opts[:default].empty?
          raise ArgumentError, "multiple argument type cannot be deduced from an empty array for '#{opts[:default][0].class.name}'"
        end
        case opts[:default][0]    # the first element determines the types
        when Integer; :ints
        when Numeric; :floats
        when String; :strings
        when IO; :ios
        when Date; :dates
        else
          raise ArgumentError, "unsupported multiple argument type '#{opts[:default][0].class.name}'"
        end
      when nil; nil
      else
        raise ArgumentError, "unsupported argument type '#{opts[:default].class.name}'"
      end

    raise ArgumentError, ":type specification and default type don't match (default type is #{type_from_default})" if opts[:type] && type_from_default && opts[:type] != type_from_default

    opts[:type] = opts[:type] || type_from_default || :flag

    ## fill in :long
    opts[:long] = opts[:long] ? opts[:long].to_s : name.to_s.gsub("_", "-")
    opts[:long] = case opts[:long]
      when /^--([^-].*)$/; $1
      when /^[^-]/; opts[:long]
      else; raise ArgumentError, "invalid long option name #{opts[:long].inspect}"
    end
    raise ArgumentError, "long option name #{opts[:long].inspect} is already taken; please specify a (different) :long" if @long[opts[:long]]

    ## fill in :short
    opts[:short] = opts[:short].to_s if opts[:short] unless opts[:short] == :none
    opts[:short] = case opts[:short]
      when /^-(.)$/; $1
      when nil, :none, /^.$/; opts[:short]
      else raise ArgumentError, "invalid short option name '#{opts[:short].inspect}'"
    end

    if opts[:short]
      raise ArgumentError, "short option name #{opts[:short].inspect} is already taken; please specify a (different) :short" if @short[opts[:short]]
      raise ArgumentError, "a short option name can't be a number or a dash" if opts[:short] =~ INVALID_SHORT_ARG_REGEX
    end

    ## fill in :default for flags
    opts[:default] = false if opts[:type] == :flag && opts[:default].nil?

    ## autobox :default for :multi (multi-occurrence) arguments
    opts[:default] = [opts[:default]] if opts[:default] && opts[:multi] && !opts[:default].is_a?(Array)

    ## fill in :multi
    opts[:multi] ||= false

    opts[:desc] ||= desc
    @long[opts[:long]] = name
    @short[opts[:short]] = name if opts[:short] && opts[:short] != :none
    @specs[name] = opts
    @order << [:opt, name]
  end

  ## Sets the version string. If set, the user can request the version
  ## on the commandline. Should probably be of the form "<program name>
  ## <version number>".
  def version s=nil; @version = s if s; @version end

  ## Adds text to the help display. Can be interspersed with calls to
  ## #opt to build a multi-section help page.
  def banner s; @order << [:text, s] end
  alias :text :banner

  ## Marks two (or more!) options as requiring each other. Only handles
  ## undirected (i.e., mutual) dependencies. Directed dependencies are
  ## better modeled with Trollop::die.
  def depends *syms
    syms.each { |sym| raise ArgumentError, "unknown option '#{sym}'" unless @specs[sym] }
    @constraints << [:depends, syms]
  end
  
  ## Marks two (or more!) options as conflicting.
  def conflicts *syms
    syms.each { |sym| raise ArgumentError, "unknown option '#{sym}'" unless @specs[sym] }
    @constraints << [:conflicts, syms]
  end

  ## Defines a set of words which cause parsing to terminate when
  ## encountered, such that any options to the left of the word are
  ## parsed as usual, and options to the right of the word are left
  ## intact.
  ##
  ## A typical use case would be for subcommand support, where these
  ## would be set to the list of subcommands. A subsequent Trollop
  ## invocation would then be used to parse subcommand options, after
  ## shifting the subcommand off of ARGV.
  def stop_on *words
    @stop_words = [*words].flatten
  end

  ## Similar to #stop_on, but stops on any unknown word when encountered
  ## (unless it is a parameter for an argument). This is useful for
  ## cases where you don't know the set of subcommands ahead of time,
  ## i.e., without first parsing the global options.
  def stop_on_unknown
    @stop_on_unknown = true
  end

  ## Parses the commandline. Typically called by Trollop::options,
  ## but you can call it directly if you need more control.
  ##
  ## throws CommandlineError, HelpNeeded, and VersionNeeded exceptions.
  def parse cmdline=ARGV
    vals = {}
    required = {}

    opt :version, "Print version and exit" if @version unless @specs[:version] || @long["version"]
    opt :help, "Show this message" unless @specs[:help] || @long["help"]

    @specs.each do |sym, opts|
      required[sym] = true if opts[:required]
      vals[sym] = opts[:default]
      vals[sym] = [] if opts[:multi] && !opts[:default] # multi arguments default to [], not nil
    end

    resolve_default_short_options!

    ## resolve symbols
    given_args = {}
    @leftovers = each_arg cmdline do |arg, params|
      ## handle --no- forms
      arg, negative_given = if arg =~ /^--no-([^-]\S*)$/
        ["--#{$1}", true]
      else
        [arg, false]
      end

      sym = case arg
        when /^-([^-])$/; @short[$1]
        when /^--([^-]\S*)$/; @long[$1] || @long["no-#{$1}"]
        else; raise CommandlineError, "invalid argument syntax: '#{arg}'"
      end

      sym = nil if arg =~ /--no-/ # explicitly invalidate --no-no- arguments

      raise CommandlineError, "unknown argument '#{arg}'" unless sym

      if given_args.include?(sym) && !@specs[sym][:multi]
        raise CommandlineError, "option '#{arg}' specified multiple times"
      end

      given_args[sym] ||= {}
      given_args[sym][:arg] = arg
      given_args[sym][:negative_given] = negative_given
      given_args[sym][:params] ||= []

      # The block returns the number of parameters taken.
      num_params_taken = 0

      unless params.nil?
        if SINGLE_ARG_TYPES.include?(@specs[sym][:type])
          given_args[sym][:params] << params[0, 1]  # take the first parameter
          num_params_taken = 1
        elsif MULTI_ARG_TYPES.include?(@specs[sym][:type])
          given_args[sym][:params] << params        # take all the parameters
          num_params_taken = params.size
        end
      end

      num_params_taken
    end

    ## check for version and help args
    raise VersionNeeded if given_args.include? :version
    raise HelpNeeded if given_args.include? :help

    ## check constraint satisfaction
    @constraints.each do |type, syms|
      constraint_sym = syms.find { |sym| given_args[sym] }
      next unless constraint_sym

      case type
      when :depends
        syms.each { |sym| raise CommandlineError, "--#{@specs[constraint_sym][:long]} requires --#{@specs[sym][:long]}" unless given_args.include? sym }
      when :conflicts
        syms.each { |sym| raise CommandlineError, "--#{@specs[constraint_sym][:long]} conflicts with --#{@specs[sym][:long]}" if given_args.include?(sym) && (sym != constraint_sym) }
      end
    end

    required.each do |sym, val|
      raise CommandlineError, "option --#{@specs[sym][:long]} must be specified" unless given_args.include? sym
    end

    ## parse parameters
    given_args.each do |sym, given_data|
      arg, params, negative_given = given_data.values_at :arg, :params, :negative_given

      opts = @specs[sym]
      raise CommandlineError, "option '#{arg}' needs a parameter" if params.empty? && opts[:type] != :flag

      vals["#{sym}_given".intern] = true # mark argument as specified on the commandline

      case opts[:type]
      when :flag
        vals[sym] = (sym.to_s =~ /^no_/ ? negative_given : !negative_given)
      when :int, :ints
        vals[sym] = params.map { |pg| pg.map { |p| parse_integer_parameter p, arg } }
      when :float, :floats
        vals[sym] = params.map { |pg| pg.map { |p| parse_float_parameter p, arg } }
      when :string, :strings
        vals[sym] = params.map { |pg| pg.map { |p| p.to_s } }
      when :io, :ios
        vals[sym] = params.map { |pg| pg.map { |p| parse_io_parameter p, arg } }
      when :date, :dates
        vals[sym] = params.map { |pg| pg.map { |p| parse_date_parameter p, arg } }
      end

      if SINGLE_ARG_TYPES.include?(opts[:type])
        unless opts[:multi]       # single parameter
          vals[sym] = vals[sym][0][0]
        else                      # multiple options, each with a single parameter
          vals[sym] = vals[sym].map { |p| p[0] }
        end
      elsif MULTI_ARG_TYPES.include?(opts[:type]) && !opts[:multi]
        vals[sym] = vals[sym][0]  # single option, with multiple parameters
      end
      # else: multiple options, with multiple parameters
    end

    ## modify input in place with only those
    ## arguments we didn't process
    cmdline.clear
    @leftovers.each { |l| cmdline << l }

    ## allow openstruct-style accessors
    class << vals
      def method_missing(m, *args)
        self[m] || self[m.to_s]
      end
    end
    vals
  end

  def parse_date_parameter param, arg #:nodoc:
    begin
      begin
        time = Chronic.parse(param)
      rescue NameError
        # chronic is not available
      end
      time ? Date.new(time.year, time.month, time.day) : Date.parse(param)
    rescue ArgumentError
      raise CommandlineError, "option '#{arg}' needs a date"
    end
  end

  ## Print the help message to +stream+.
  def educate stream=$stdout
    width # hack: calculate it now; otherwise we have to be careful not to
          # call this unless the cursor's at the beginning of a line.
    left = {}
    @specs.each do |name, spec|
      left[name] = "--#{spec[:long]}" +
        (spec[:type] == :flag && spec[:default] ? ", --no-#{spec[:long]}" : "") +
        (spec[:short] && spec[:short] != :none ? ", -#{spec[:short]}" : "") +
        case spec[:type]
        when :flag; ""
        when :int; " <i>"
        when :ints; " <i+>"
        when :string; " <s>"
        when :strings; " <s+>"
        when :float; " <f>"
        when :floats; " <f+>"
        when :io; " <filename/uri>"
        when :ios; " <filename/uri+>"
        when :date; " <date>"
        when :dates; " <date+>"
        end
    end

    leftcol_width = left.values.map { |s| s.length }.max || 0
    rightcol_start = leftcol_width + 6 # spaces

    unless @order.size > 0 && @order.first.first == :text
      stream.puts "#@version\n" if @version
      stream.puts "Options:"
    end

    @order.each do |what, opt|
      if what == :text
        stream.puts wrap(opt)
        next
      end

      spec = @specs[opt]
      stream.printf "  %#{leftcol_width}s:   ", left[opt]
      desc = spec[:desc] + begin
        default_s = case spec[:default]
        when $stdout; "<stdout>"
        when $stdin; "<stdin>"
        when $stderr; "<stderr>"
        when Array
          spec[:default].join(", ")
        else
          spec[:default].to_s
        end

        if spec[:default]
          if spec[:desc] =~ /\.$/
            " (Default: #{default_s})"
          else
            " (default: #{default_s})"
          end
        else
          ""
        end
      end
      stream.puts wrap(desc, :width => width - rightcol_start - 1, :prefix => rightcol_start)
    end
  end

  def width #:nodoc:
    @width ||= if $stdout.tty?
      begin
        require 'curses'
        Curses::init_screen
        x = Curses::cols
        Curses::close_screen
        x
      rescue Exception
        80
      end
    else
      80
    end
  end

  def wrap str, opts={} # :nodoc:
    if str == ""
      [""]
    else
      str.split("\n").map { |s| wrap_line s, opts }.flatten
    end
  end

  ## The per-parser version of Trollop::die (see that for documentation).
  def die arg, msg
    if msg
      $stderr.puts "Error: argument --#{@specs[arg][:long]} #{msg}."
    else
      $stderr.puts "Error: #{arg}."
    end
    $stderr.puts "Try --help for help."
    exit(-1)
  end

private

  ## yield successive arg, parameter pairs
  def each_arg args
    remains = []
    i = 0

    until i >= args.length
      if @stop_words.member? args[i]
        remains += args[i .. -1]
        return remains
      end
      case args[i]
      when /^--$/ # arg terminator
        remains += args[(i + 1) .. -1]
        return remains
      when /^--(\S+?)=(.*)$/ # long argument with equals
        yield "--#{$1}", [$2]
        i += 1
      when /^--(\S+)$/ # long argument
        params = collect_argument_parameters(args, i + 1)
        unless params.empty?
          num_params_taken = yield args[i], params
          unless num_params_taken
            if @stop_on_unknown
              remains += args[i + 1 .. -1]
              return remains
            else
              remains += params
            end
          end
          i += 1 + num_params_taken
        else # long argument no parameter
          yield args[i], nil
          i += 1
        end
      when /^-(\S+)$/ # one or more short arguments
        shortargs = $1.split(//)
        shortargs.each_with_index do |a, j|
          if j == (shortargs.length - 1)
            params = collect_argument_parameters(args, i + 1)
            unless params.empty?
              num_params_taken = yield "-#{a}", params
              unless num_params_taken
                if @stop_on_unknown
                  remains += args[i + 1 .. -1]
                  return remains
                else
                  remains += params
                end
              end
              i += 1 + num_params_taken
            else # argument no parameter
              yield "-#{a}", nil
              i += 1
            end
          else
            yield "-#{a}", nil
          end
        end
      else
        if @stop_on_unknown
          remains += args[i .. -1]
          return remains
        else
          remains << args[i]
          i += 1
        end
      end
    end

    remains
  end

  def parse_integer_parameter param, arg
    raise CommandlineError, "option '#{arg}' needs an integer" unless param =~ /^\d+$/
    param.to_i
  end

  def parse_float_parameter param, arg
    raise CommandlineError, "option '#{arg}' needs a floating-point number" unless param =~ FLOAT_RE
    param.to_f
  end

  def parse_io_parameter param, arg
    case param
    when /^(stdin|-)$/i; $stdin
    else
      require 'open-uri'
      begin
        open param
      rescue SystemCallError => e
        raise CommandlineError, "file or url for option '#{arg}' cannot be opened: #{e.message}"
      end
    end
  end

  def collect_argument_parameters args, start_at
    params = []
    pos = start_at
    while args[pos] && args[pos] !~ PARAM_RE && !@stop_words.member?(args[pos]) do
      params << args[pos]
      pos += 1
    end
    params
  end

  def resolve_default_short_options!
    @order.each do |type, name|
      next unless type == :opt
      opts = @specs[name]
      next if opts[:short]

      c = opts[:long].split(//).find { |d| d !~ INVALID_SHORT_ARG_REGEX && !@short.member?(d) }
      if c # found a character to use
        opts[:short] = c
        @short[c] = name
      end
    end
  end

  def wrap_line str, opts={}
    prefix = opts[:prefix] || 0
    width = opts[:width] || (self.width - 1)
    start = 0
    ret = []
    until start > str.length
      nextt = 
        if start + width >= str.length
          str.length
        else
          x = str.rindex(/\s/, start + width)
          x = str.index(/\s/, start) if x && x < start
          x || str.length
        end
      ret << (ret.empty? ? "" : " " * prefix) + str[start ... nextt]
      start = nextt + 1
    end
    ret
  end

  ## instance_eval but with ability to handle block arguments
  ## thanks to _why: http://redhanded.hobix.com/inspect/aBlockCostume.html
  def cloaker &b
    (class << self; self; end).class_eval do
      define_method :cloaker_, &b
      meth = instance_method :cloaker_
      remove_method :cloaker_
      meth
    end
  end
end

## The easy, syntactic-sugary entry method into Trollop. Creates a Parser,
## passes the block to it, then parses +args+ with it, handling any errors or
## requests for help or version information appropriately (and then exiting).
## Modifies +args+ in place. Returns a hash of option values.
##
## The block passed in should contain zero or more calls to +opt+
## (Parser#opt), zero or more calls to +text+ (Parser#text), and
## probably a call to +version+ (Parser#version).
##
## The returned block contains a value for every option specified with
## +opt+.  The value will be the value given on the commandline, or the
## default value if the option was not specified on the commandline. For
## every option specified on the commandline, a key "<option
## name>_given" will also be set in the hash.
##
## Example:
##
##   require 'trollop'
##   opts = Trollop::options do
##     opt :monkey, "Use monkey mode"                    # a flag --monkey, defaulting to false
##     opt :name, "Monkey name", :type => :string        # a string --name <s>, defaulting to nil
##     opt :num_limbs, "Number of limbs", :default => 4  # an integer --num-limbs <i>, defaulting to 4
##   end
##
##   ## if called with no arguments
##   p opts # => {:monkey=>false, :name=>nil, :num_limbs=>4, :help=>false}
##
##   ## if called with --monkey
##   p opts # => {:monkey=>true, :name=>nil, :num_limbs=>4, :help=>false, :monkey_given=>true}
##
## See more examples at http://trollop.rubyforge.org.
def options args=ARGV, *a, &b
  @last_parser = Parser.new(*a, &b)
  with_standard_exception_handling(@last_parser) { @last_parser.parse args }
end

## If Trollop::options doesn't do quite what you want, you can create a Parser
## object and call Parser#parse on it. That method will throw CommandlineError,
## HelpNeeded and VersionNeeded exceptions when necessary; if you want to
## have these handled for you in the standard manner (e.g. show the help
## and then exit upon an HelpNeeded exception), call your code from within
## a block passed to this method.
##
## Note that this method will call System#exit after handling an exception!
##
## Usage example:
##
##   require 'trollop'
##   p = Trollop::Parser.new do
##     opt :monkey, "Use monkey mode"                     # a flag --monkey, defaulting to false
##     opt :goat, "Use goat mode", :default => true       # a flag --goat, defaulting to true
##   end
##
##   opts = Trollop::with_standard_exception_handling p do
##     o = p.parse ARGV
##     raise Trollop::HelpNeeded if ARGV.empty? # show help screen
##     o
##   end
##
## Requires passing in the parser object.

def with_standard_exception_handling parser
  begin
    yield
  rescue CommandlineError => e
    $stderr.puts "Error: #{e.message}."
    $stderr.puts "Try --help for help."
    exit(-1)
  rescue HelpNeeded
    parser.educate
    exit
  rescue VersionNeeded
    puts parser.version
    exit
  end
end

## Informs the user that their usage of 'arg' was wrong, as detailed by
## 'msg', and dies. Example:
##
##   options do
##     opt :volume, :default => 0.0
##   end
##
##   die :volume, "too loud" if opts[:volume] > 10.0
##   die :volume, "too soft" if opts[:volume] < 0.1
##
## In the one-argument case, simply print that message, a notice
## about -h, and die. Example:
##
##   options do
##     opt :whatever # ...
##   end
##
##   Trollop::die "need at least one filename" if ARGV.empty?
def die arg, msg=nil
  if @last_parser
    @last_parser.die arg, msg
  else
    raise ArgumentError, "Trollop::die can only be called after Trollop::options"
  end
end

module_function :options, :die, :with_standard_exception_handling

end # module


# =======================================================================



ThreadGrep.new.main
